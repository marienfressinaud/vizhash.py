#!/bin/env python2
# -*- coding: utf-8 -*-

'''
    Visual Hash Python implementation.

    Based on VizHash_GD and VizHash.js:

    - https://github.com/sebsauvage/VizHash
    - https://github.com/sametmax/VizHash.js

    This is a free software under the zlib/libpng license:

    - http://opensource.org/licenses/zlib-license.php

    Requires:

    - Pillow: http://python-pillow.github.io/

    Usages:

    - In command line: `./vizash.py --size=50x50 my_string > img.png`
    - In your source code:

    ```
    import vizhash.vizhash

    img = vizhash.vizhash.draw('my_string', size=(50, 50))
    fp = open('img.png', 'w')
    img.save(fp)
    ```

    Please note images are always in the PNG format.

    Compatible Python 2.7 and higher (including branch 3.x).
'''


from __future__ import division, print_function, unicode_literals

import argparse
import sys
import hashlib
import PIL.Image
import PIL.ImageDraw


# Handle 2.x / 3.x compatibility for the range function
if sys.version_info[0] == 2:
    range = xrange


_base_color = None
_int_array = None


def hash_string(string):
    '''Hash a string and add more data to generate the image.

    :param string: the original string to hash.
    :type string: unicode (Py2) | str (Py3)
    :return: an hexadecimal hash of string.
    :rtype: unicode (Py2) | str (Py3)

    '''

    string = string.encode('utf-8')
    hash_ = hashlib.sha1(string).hexdigest() + hashlib.md5(string).hexdigest()
    if sys.version_info[0] == 2:
        hash_ = hash_.decode('utf-8')

    return hash_ + hash_[::-1]


def get_int_value(value):
    '''Return a generator of integer from an hexadecimal string

    :param value: the hexadecimal string.
    :type string: unicode (Py2) | str (Py3)
    :return: a generator wich iter indefinitely on integer values
        from the initial string.
    :rtype: generator(int)

    '''

    int_array = [int(value[i:i + 2], 16) for i in range(0, len(value), 2)]

    i = 0
    while True:
        yield int_array[i]
        i = (i + 1) % len(int_array)


def list_colors(start, end, size):
    '''Return a list of colors between start and end.

    It is used to generate a gradient.

    :param start: the initial color of the gradient.
    :type start: tuple(int, int, int)
    :param end: the last color of the gradient.
    :type end: tuple(int, int, int)
    :param size: the size in number of pixels of the gradient.
    :type size: int
    :return: a list of colors.
    :rtype: list(tuple(int, int, int))

    '''

    delta = [end[i] - start[i] for i in range(3)]
    return [
        tuple([start[j] + (delta[j] * i)//size for j in range(3)])
        for i in range(size)
    ]


def rect_helper(points):
    '''Reorganize point coordinates to represent a rectangle.

    :param points: list of coordinates in the following order: x0, y0, x1, y1.
    :type points: list(int, int, int, int)
    :return: the list of coordinates where x1 > x0 and y1 > y0.
    :type points: list(int, int, int, int)

    '''

    x0, y0, x1, y1 = points
    if x0 > x1:
        x0, x1 = x1, x0
    if y0 > y1:
        y0, y1 = y1, y0
    return [x0, y0, x1, y1]


def add_gradient(canvas):
    '''Add a gradient on the whole canvas.

    The orientation is determined by using a _int_array value.
    The gradient colors go from _base_color to black.

    :param canvas: the canvas on which we draw.
    :type canvas: PIL.ImageDraw

    '''

    is_horizontal = next(_int_array) % 2 == 0
    # Useful to automate next calculations.
    if is_horizontal:
        size, other_size = canvas.im.size
    else:
        other_size, size = canvas.im.size

    # Generate the list of gradient colors
    gradient = list_colors(_base_color, (0, 0, 0), size)
    for i, color in enumerate(gradient):
        # We calculate coordinates of the line we draw. Since is_horizontal
        # is a boolean, it'll be converted to 0 (False) or 1 (True) so
        # calculation of values is quite easy to automate.
        x0 = i * is_horizontal
        y0 = i * (not is_horizontal)
        x1 = i*is_horizontal + other_size*(not is_horizontal)
        y1 = i*(not is_horizontal) + other_size*is_horizontal

        canvas.line([x0, y0, x1, y1], fill=color, width=1)


def add_shape(canvas, shape, color):
    '''Add a shape on the canvas.

    The resulting shape will depend on the given integer and on the color.
    Coordinates are generated by using _int_array values.

    :param canvas: the canvas on which we draw.
    :type canvas: PIL.ImageDraw
    :param shape: an integer which determine the final appearance.
    :type shape: int
    :param color: the color of the shape.
    :type color: tuple(int, int, int)

    '''

    width, height = canvas.im.size

    # Helper functions which return coordinates mapped on the canvas size.
    def get_x():
        return width * next(_int_array) // 256

    def get_y():
        return height * next(_int_array) // 256

    # There are 4 final shapes (rectangle, ellipse, polygon and chord/arc)
    shape = shape % 7
    if shape == 0:
        canvas.rectangle(
            rect_helper([get_x(), get_y(), get_x(), get_y()]),
            fill=color
        )
    elif shape in (1, 2):
        canvas.ellipse(
            rect_helper([get_x(), get_y(), get_x(), get_y()]),
            fill=color
        )
    elif shape == 3:
        canvas.polygon(
            [get_x(), get_y(), get_x(), get_y(),
             get_x(), get_y(), get_x(), get_y()],
            fill=color
        )
    elif shape in (4, 5, 6):
        start = int(next(_int_array) * 360 // 256)
        end = int(start + (next(_int_array) * 180 // 256))
        canvas.chord(
            rect_helper([get_x(), get_y(), get_x(), get_y()]),
            start, end,
            fill=color
        )


def add_shapes(canvas):
    '''Draw 8 shapes on the canvas.

    Each shape and color is generated by using _int_array.

    :param canvas: the canvas on which we draw.
    :type canvas: PIL.ImageDraw

    '''

    color = _base_color
    for i in range(7):
        shape = next(_int_array)
        color = tuple([(c + next(_int_array) // 25) % 256 for c in color])
        add_shape(canvas, shape, color)

    color = (next(_int_array), next(_int_array), next(_int_array))
    add_shape(canvas, next(_int_array), color)


def draw(string, size=(80, 80)):
    '''Draw and return an image representing a visual hash of a string.

    The max size image is 256x256.

    :param string: the string we want to visualise.
    :type string: unicode (Py2) | str (Py3)
    :param size: the size of the image.
    :type size: tuple(int, int)
    :raises ValueError: when image size is over 256x256.

    '''

    if size[0] > 256 or size[1] > 256:
        raise ValueError('Max image size is 256 x 256')

    # Initialize useful values that we'll use later.
    global _int_array, _base_color
    hash_ = hash_string(string)
    _int_array = get_int_value(hash_)
    _base_color = (next(_int_array), next(_int_array), next(_int_array))

    # Create an image and get a "canvas" to write inside
    image = PIL.Image.new('RGB', size)
    canvas = PIL.ImageDraw.Draw(image)
    add_gradient(canvas)
    add_shapes(canvas)
    del canvas

    return image


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('-s', '--size', default='80x80', required=False,
                        help='the image size (e.g. 80x80)')
    parser.add_argument('string', help='the string to visualize')
    args = parser.parse_args()

    # Make sure to get the correct values from the command line, especially
    # a decoded string!
    # We MUST use the raw output in Python 3 (sys.stdout.buffer) to have a
    # clean image output.
    if sys.version_info[0] == 2:
        output = sys.stdout
        string = args.string.decode('utf-8')
    elif sys.version_info[0] == 3:
        output = sys.stdout.buffer
        string = args.string

    try:
        size = [int(i) for i in args.size.split('x')]
    except (ValueError, IndexError):
        parser.print_help()
        sys.exit(2)

    image = draw(string, size)
    image.save(output, format='PNG')
